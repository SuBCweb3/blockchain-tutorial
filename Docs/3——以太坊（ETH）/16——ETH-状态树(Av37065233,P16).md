**16. ETH 状态树**

15章说过，以太坊中采用的是一种基于账户的模式，系统中显式地维护每个账户上有多少余额。这章看下用什么样的数据结构来实现这样一个 account-based 的架构。

## 设计目标

我们要完成的是什么功能？是一个从账户地址到账户状态的映射。

- **地址 (Address)**：这个 address 就是这个账户的地址，以太坊中用的账户地址是 160 位的，也就是 20 个字节，一般把它表示成 40 个 16 进制的数。
- **状态 (State)**：这个状态就是我们上个章节说的外部账户和合约账户的状态，包括余额、交易次数等。对于合约账户还包括代码和存储。

## 数据结构设计思路

我们设计什么样的数据结构来实现这个映射呢？这从直观上看像是个很典型的 Key-Value 对。给出一个账户地址，我要找到相应的账户状态。

### 方案一：哈希表

一个比较直观的想法是，我们就用一个哈希表来实现。系统中的全节点维护一个哈希表：
- 每次你有一个新的账户，插入到哈希表里面
- 你要查询账户的余额，就直接在哈希表中查询

如果不考虑哈希碰撞的话，那么基本上这个查询的效率是常数时间内完成的，更新也是很容易在哈希表中更新。

**问题分析：**

这个方案有什么问题吗？

最大的问题是：如果需要提供 Merkle Proof 怎么提供？

比如说你要跟一个人签合同，希望他能证明一下他有多少钱，证明一下账户余额，怎么提供这个证明？

一种方法是把这个哈希表中的元素组织成一颗 Merkle Tree，然后算出一个根哈希值。这个根哈希值要保存在 Block Header 里，就像我们说的，比特币当中也有 Merkle Tree，也有根哈希值保存在 Block Header 里公布出去。那么这个根哈希值只要是正确的，就能保证底下的树不会被篡改。

但是这有什么问题吗？

**问题就在于：** 如果有个新区块发布怎么办？新区块中包含有新的交易，我们要执行这个交易，就必然会使这个哈希表的内容发生变化。我们发布下一个区块的时候，要把这些哈希表中的内容再重新组织成一颗 Merkle Tree 吗？

那这个代价是不是太大了？实际上真正发生变化的账户状态只是一小部分。因为你只有那个区块里包含的交易所关联的账户才会发生变化，大多数账户的状态是不变的。所以每次你都重新构造一颗 Merkle Tree，这个代价是很大的。

**与比特币的区别：**

比特币系统当中不也是每出一个新的区块，你也要构造一个 Merkle Tree 吗？为什么比特币没有这个问题？

那个 Merkle Tree 是用来干嘛的？是把区块里包含的那些交易组织成一个 Merkle Tree。每次发布一个新的区块，又有一系列新的交易。所以比特币中的 Merkle Tree 是 immutable 的，就是每次发布一个新的区块对应着一颗 Merkle Tree。然后这颗 Merkle Tree 构建完之后是不会再改的，下次再发布一个新的区块，再构建一个新的。

区块里有多少个交易呢？最多差不多 4000 个，按照 1MB 每个交易大概是 250 个字节左右，最多 4000 个。这个其实是一个上限。因为我们区块链上看过一些区块，很多区块里的交易数目根本到不了 4000 个，有好多区块就只有几百个，甚至还有的可能更少。

所以我们每次发布一个区块，比特币里构建一个 Merkle Tree，是要把这几百个到几千个交易构建成一个 Merkle Tree。这里如果我们采用这种方法会是什么情况？

是要把所有的以太坊账户一起构建成一个 Merkle Tree。这个数目就比我们刚才说的每个区块当中的几百个几千个交易要高出好几个数量级。相当于你每次发布一个区块，你要把所有的账户遍历一遍，构建出一个 Merkle Tree。下次再有个新的区块，再把所有的账户遍历一遍，构建出新的 Merkle Tree。

除了提供 Merkle Proof 证明这个账户上有多少钱之外，这个 Merkle Tree 还有另外一个很重要的作用：**维护各个全节点之间状态的一致性。**

如果你没有这个根哈希值公布出来，每个节点就是在内部本地维护一个数据结构。那怎么知道你这个数据结构的状态跟别人数据结构的状态是不是一致呢？我们各个全节点之间要保持状态的一致才行。这其实也是比特币中为什么把这个根哈希值写在块头里的一个原因。就是对于当前这个区块中包含哪些交易，所有的全节点要有一个共识。

**结论：** 如果就简单的每个全节点在本地维护一个哈希表，需要构建 Merkle Tree 的时候，构建出 Merkle Tree 根哈希值放到区块头里，这个方法是不行的。哈希表本身的效率是挺好的，你插入更改，效率都很好。但是每次去构建这个 Merkle Tree 的代价太大。

### 方案二：直接使用 Merkle Tree

我们考虑第二种方案，能不能我们就不要哈希表了，我们直接就用一颗 Merkle Tree，所有的账户都放进去。你要改的时候直接在那 Merkle Tree 里改。因为你每个区块更新的只是一小部分账户，所以你改的只是 Merkle Tree 中的一小部分，这个方法行吗？

**问题分析：**

这个方法的问题在于：Merkle Tree 没有提供一个高效的查找和更新的方法。想想比特币当中的 Merkle Tree 是怎么构建的？是最底下一层是 transaction，然后哈希值放到上面节点里两两结合，然后再取个哈希往上等。这从底下一层往上去，他没有提供一个快速查找和更新的方法。

还有一个问题：如果我们这样构建 Merkle Tree，就直接把账户都放在一个大的 Merkle Tree 里，这个 Merkle Tree 要不要排序？

如果我们不排序会怎么样？

1. 不排序的话查找速度会慢
2. 更重要的是，如果不排序，就没法证明某个账户不存在

在比特币中，你要证明一个交易包含在区块里是不用排序的。你要证明一个交易没有包含在区块里，是需要用排序的版本，否则的话证明的代价就变成了线性的，变成 O(n) 了。

不排序还有另外一个问题：这些账户组成这个 Merkle Tree 叶节点是这些账户的信息，如果不规定这些账户在叶节点的出现顺序，那么这样构建出来的 Merkle Tree 不是唯一的。

比如说系统中有那么多全节点，每个全节点按照自己的某个顺序，比如说他听到某个交易的顺序构建一个 Merkle Tree。那叶节点的顺序是乱的，每个节点自己决定的，最后构建出来的 Merkle Tree 是不一样的，算出的根哈希值也是不一样的。

**与比特币的区别：**

比特币当中不也是不排序吗？为什么比特币当中就没有这个问题？

比特币当中其实每个全节点收到的交易的顺序也是不一样的。从理论上说，这样构建出的 Merkle Tree 根哈希值也是不一样。但是比特币有一个区别：**最后是谁说了算？获得记账权的那个节点说了算。**

所以比特币中是怎么运行的：每个节点在本地组装一个候选区块，这个节点自己决定哪些交易应该被打包到这个区块里，以什么样的顺序打包在这个区块里，是这个节点自己决定的。然后去挖矿，去竞争记账权。如果他没有抢到记账权，他做的决定别人是没必要知道的。只有他获得记账权，他发布出去了，而且这个区块最终成为一个被大家接受的区块。那么这个时候顺序是谁确定的？发布这个区块的节点确定了。

那我们这里为什么不能这么干？

如果以太坊中也这么干，需要怎么样？需要把这个账户的状态发布到区块里。你也可以说是每个全节点自己决定怎么把账户组织成一个 Merkle Tree，算出根哈希值去挖矿，但是你怎么让别人知道这个顺序，你得把它发布到区块里。但你发布的是一个所有账户的状态，不是发布的区块里包含的交易。

这差好几个数量级。你发布一个交易的话，只需要几百个几千个交易，而且这个交易是必须得发布的，这个代价你必须得付出。你不发布怎么办？别人怎么知道你这个交易？所以这个交易是必须得发布的。

账户状态是可以维护在本地的，而且大多数账户状态是不变的。你一个区块里那些交易只能改很少的一些账户，大多数账户状态是不变的。而且你重复发布，每隔十几秒发布一个新区块，你把所有状态都打包发布一遍，下次再过十几秒再发布一遍，这个是不可行的。

**排序的问题：**

我们接着这个方案继续讲。刚才只是说明了不排序的 Merkle Tree 是不行的，存在好多问题。那我排序，我用排序的 Merkle Tree 是不是就没问题？

你觉得会有什么问题？

**问题：** 你新增一个账户怎么办？你产生一个新账户的账户地址是随机的，他插入到叶节点中的位置很可能是插在中间的。随机产生的一个账户地址，那后面这些树的结构都得变。那你得重新再产生一遍 Merkle Tree，这又变成了每次我要产生一遍 Merkle Tree。

严格地说，你产生账户的时候，别人是没必要知道的。只有这个账户对外发生了一些交互，比如他往外转账或者别人往里面转账，这个系统才需要知道。

新产生一个账户，对外发生了交互，我需要把它加入到我的数据结构里，这话没有错。但问题是这个加入的代价有多大？如果你就直接用哈希表的话，这代价是常数的。你要用 Merkle Tree 的话，你可能有大半棵树得重构，这就是代价。这个代价同样是太大了。

所以你用排序的 Merkle Tree 也有问题，你插入的话代价太大。删除代价也大。删除其实可以不删，而且说实在的，区块链里你删东西难度是比较大的。区块链所谓叫不可篡改的账本，是说你往里添东西容易，你想删东西难。其实以太坊中没有显式的删除账户的操作。有的账户上就一点钱，就一两个 wei，你也不能把它删掉。

## 以太坊的解决方案：MPT

我们大家都达成一致了，这两个简单的数据结构是不行的，那怎么办呢？

以太坊采用的方法是用一个叫 MPT 的结构：**Merkle Patricia Tree**。

在讲 MPT 之前，我们先讲一个简单的数据结构。

### Trie 树

这个 Trie 是从哪儿来的呢？英文中有个单词叫 retrieval，从这里来的，信息检索。一般来说，这个中文翻译成中文叫字典树，叫前缀树。它也是一种 Key-Value Store。

一般来说这个 key 是字符串，用的比较多。比如说我们有一些单词，我们把它组织成一个 Trie 的树形结构。比如说我们有这几个单词：

- General
- Genesis
- God
- Go
- Good

还记得 Genesis 是什么意思吗？我们说区块链的第一个区块叫什么？Genesis Block 创世块。

下面我们看一下组织成一个 Trie 的结果：

这几个单词都是以 G 开头的。一开始是这个 G，然后第二个字母就开始分叉了，左边是 E，右边是 O。前两个单词接下来都是 N 和 E，然后在下面再分开，左边是 R，右边是 S。右边这个分支 O 这个分支，Go 就已经结束了。

在这个例子中我们可以看到单词有可能在这个 Trie 的一个中间节点结束。左边是 D，右边是 O，左边变成了 God，右边下来是 Good。这就是这个 Trie 的结构。

**Trie 的特点：**

1. **分支数目取决于 Key 值里每个元素的取值范围**
   - 这个例子当中每个都是英文单词，而且是小写的，所以每个节点的分叉数目最多是 26 个
   - 加上一个结束标志位，表示到这个地方这个单词是不是就结束了
   - 在我们这个以太坊里面，地址是表示成 40 个 16 进制的数，所以这个分叉数目（有时候管它叫 branching factor）是 17，因为是 16 进制的 0 到 F 加上一个结束标志符，所以是 17

2. **Trie 的查找效率取决于这个 Key 的长度**
   - 键值越长，查找需要访问内存的次数就越多
   - 我们的应用当中这个 Key 值有多长呢？所有的键值都是一样长，都是 40，因为地址都是 40 位 16 进制的数
   - 顺便说一句，比特币跟以太坊的地址是不通用的，两个地址的格式长度都是不一样的。这有一点是类似的，就是以太坊中的地址也是公钥经过转换得来的，其实就是公钥取了哈希，然后截取一段，只要后面的部分就得到一个 160 bit 的地址

3. **Trie 不会出现碰撞**
   - 如果我们用哈希表来存储这个 Key-Value 对，从理论上说是有可能出现哈希碰撞的
   - 有可能有两个账户，这两个账户的地址是不一样的，但是恰好映射到了哈希表的同一个位置
   - 那 Trie 呢？只要两个地址不一样，最后肯定映射到树中的两个不同分支
   - 所以 Trie 是不会出现碰撞的

4. **构建顺序无关性**
   - 我们前面讲 Merkle Tree，如果你不排序的话，一个问题是你这个账户插入到 Merkle Tree 中的顺序不一样，得到的树的结构也不一样
   - 那 Trie 呢？比如说我这五个单词，我换一个顺序插到树里面，得到的是一棵不同的树吗？是一样的
   - 这就是一个特点：不论你——只要给定一组输入，这个输入不变，不论你这个输入怎么打乱重排，最后插入到这个 Trie 当中，构成的 Trie 是同一棵树
   - 这个对我们的应用来说也是很有用的。不同的节点，不论你怎么按照顺序去插入这些账户，最后构造出来的树是一样的

5. **更新的局部性**
   - 我们说每次发布一个区块，系统中绝大多数账户的状态是不变的，只有个别受到影响的账户的状态才会变
   - 所以更新操作的局部性很重要
   - 这个的局部性，比如说我要更新 Genesis 这个 key 对应的 value，在这个图当中只画出了 Key，没有画出 value
   - 要更新这个 Genesis 对应的 value，我只用访问这下面这个分支，其他分支是不用访问的，也不用遍历整棵树
   - 所以这是它的更新的局部性是很好的

### Patricia Tree（路径压缩）

我们说了 Trie 的这么多优点，Trie 就没有缺点吗？

其实 Trie 的缺点也挺明显的：**存储浪费**。

像这些节点，都只有一个子节点。对于这种一脉单传的情况，如果我们能把这些节点进行合并，那么可以减少存储的开销，同时也提高查找的效率，不用一次一个一个往下找了。

这就引入了我们说的 **Patricia Tree**。

也有人把它写成 **Radix Tree**，这个都没什么太大关系。就是这种经过了路径压缩的前缀树，有时候管它叫压缩前缀树。

那么这个例子如果进行路径压缩是什么样子的？

这就是 Patricia Tree 的结果。我们可以看到一开始的时候，这个 G 下面还是 E 跟 O 进行分叉。E 下面之后跟着都是 NE，然后再往下又是 E 跟 S 分叉，然后后面几个都合在一起了。右边这个分支也是一样的。

所以这样压缩之后有什么好处？直观上看这个树的高度明显缩短了，这树变得比较浅了，这样你访问内存的次数就会大大减少，效率就提高了。

**注意：** 对于这个 Patricia Tree 来说，如果你新插入一个单词，原来压缩的路径可能需要扩展开来。

比如说这个例子当中，假设我们又加入个词：Geometry。

如果你加入 Geometry 的话，左边这个分支就不能这么压缩了。

**路径压缩在什么情况下效果比较好？**

就我们这个例子中效果很明显，但也可能有些例子当中效果就不明显。什么情况下它效果会比较好？

更严格地说叫什么？**这个树中插入的这些键值的分布，如果是比较稀疏的情况下，做路径压缩效果比较好。**

比如说我们这个例子当中是用英文单词。如果你这个英文单词每个单词都很长，但是一共没有几个单词，那这个时候我们举个例子：

- Misunderstanding
- Decentralization（去中心化）
- Disintermediation

这个词大家知道什么意思吗？intermediary 是中间商的意思，disintermediation 是把中间商去掉。区块链的一个应用场景就是 disintermediation。区块链的价值是什么？就去掉这些中间商，让这个系统中的价值提供者跟消费者直接进行交互。

这三个单词如果你插入到一个 Trie 里面，普通的 Trie 里面会是什么样的？

基本上退化成一条线了。如果用 Patricia Tree 呢？

这个树的高度明显改善多了。

所以**键值分布比较稀疏的时候，路径压缩效果比较好。**

**那我们这个应用场景当中，键值分布是不是稀疏的呢？**

是的。我们在应用中键值是什么？是地址。地址是 160 位的，所以整个地址空间有多大？2^160，这是一个非常大的数。如果你设计一个计算机程序的算法，它需要进行的运算次数是 2^160，那这个代价我们整个所有人的有生之年都不可能算出来。这是个非常大的数。

以太坊中的账户数目，全世界的账户数目加在一起也远远没有这么大，跟这个数比是微乎其微的，所以他是非常稀疏的。

**为什么搞得这么稀疏？**

为什么不把地址长度缩短一点，这样访问效率还快，也没必要那么稀疏了。

如果地址容易被破解，就会有安全问题。或者换种说法，我们之前讨论过一个密码学原理：

以太坊跟比特币中——以太坊中的普通账户创建方法跟比特币是一样的。就是没有一个中央的节点，每个用户自己独立创建账户。你在本地产生一个公私钥对，就是一个账户。那你怎么防止两个人的账户正好碰撞呢？产生了一样的账户地址呢？

这种可能性是存在的，但是我们之前说过，这个概率比地球爆炸的概率还要小。怎么达到这么小的概率？就是你的地址要足够长，要分布足够稀疏，才不会产生碰撞。

这个可能看上去有点浪费，但这是一个去中心化的系统，防止账户冲突的唯一办法。所以它是非常稀疏的，这就是为什么我们在这个数据结构中要用路径压缩。

### MPT（Merkle Patricia Tree）

我们讲了 Trie，讲了 Patricia Tree，MPT 是什么？

**Merkle Patricia Tree。**

那 MPT 跟 PT 有什么区别？Merkle Patricia Tree 跟 Patricia Tree 有什么区别？

我们先说一说 Merkle Tree 跟普通的树有什么区别？

区块链和链表有什么区别？把普通指针换成了哈希指针。

那么这里也是一样的，**把普通指针换成了哈希指针**。

所以大家听明白了吗？就是所有的账户组织成一个 Patricia Tree，用路径压缩提高效率，然后把普通指针换成哈希指针，所以你就可以计算出一个根哈希值，这个根哈希值也是写在 Block Header 里的。

比特币的 Block Header 里只有一个根哈希值，就是这个区块里包含的交易组成的 Merkle Tree 的根哈希值。以太坊中有三个，以太坊中也有一个交易组成的叫交易树。我们现在讲的是叫状态树，账户状态组织成了一个 Merkle Patricia Tree，它的根哈希值。

**这个根哈希值有什么用？**

1. **防止篡改**：只要根哈希值不变，整个树的任何部分都没有办法被篡改。也就是说每个账户的状态都能保证它的完整性 (integrity) 是没有被篡改过的。

2. **Merkle Proof**：这个树能证明什么？
   - 能证明你有多少钱，证明你账户上的余额是多少
   - 怎么证明？就是你这个账户所在的那个分支，整个分支作为 Merkle Proof 发给这个轻节点，轻节点就可以验证一下你账户上多少钱

3. **证明不存在性**：能不能证明某个账户是不存在的？
   - 我们说排序的 Merkle Tree 的一个好处是可以证明 non-membership，这个能不能证明？
   - 能。如果你想给一个地址转账之前，你想验证一下这个全节点里有没有这个账户信息，这个能证出来
   - 或者说得更直白一点，能不能证明这个 MPT 中某个键值是不存在的？能
   - 怎么证？其实证明方法跟那个排序 Merkle Tree 类似。如果存在的话，它应该在什么样的分支里？把这个分支作为 Merkle Proof 发过去，可以证明它是不存在的

## Modified MPT

以太坊中用到的还不是原生版的 MPT，用的叫 **Modified MPT**。

就对这个 MPT 的结构做一些修改，这些修改不是很本质的修改。我们看一个例子：

这个例子当中有四个账户，右上角这四个账户。为了简单起见，这个账户地址都比较短，我们假设只有 7 位的地址，而不是 40 位的。然后账户状态我们也只显示了余额，其他的账户状态没有显示出来。

- 第一个账户有 45 个以太币
- 第二个账户比较穷，只有 1 wei，这是以太坊中最小的计量单位，1 wei 基本上可以忽略不计

然后它的节点，这个树中的节点是分为三种：

1. **Extension Node**：如果这个树的某个部位出现了路径压缩，就会有一个 Extension Node
2. **Branch Node**：分支节点
3. **Leaf Node**：叶子节点

所以这四个地址，前两位开头都是一样的 A7，所以它的根节点就是一个 Extension，这写 shared nibble（一个 nibble 就是一个 16 进制数）。

然后第三位开始就分开了，有 1、7、F，所以就有一个 Branch Node。

我们先说 1，这个 1 后面就是 1355，他只有这一个地址，所以就是跟着一个 Leaf Node 1355。

7 这个位置有两个地址，这两个地址接下来都是 D 和 3，所以连着是个 Extension，也是路径压缩 D 和 3。然后再往下是 3 和 9 分开了，所以跟着一个 Branch Node 分支节点 3 和 9。

然后下面两个叶子节点就是最后一位，这个例子当中最后一位都是 7。

最后这个 F 就是上面分开的 FA7F，下面就是 9365，就跟着一个 Leaf Node 9365。

这就是这个状态树。

**Modified MPT 的特点：**

它是用哈希指针。这个意思不是说简单指针。比如说 7 这个位置，它连着一个 Extension Node，是说 7 这个位置里面存的值是下面这个节点的哈希值。

如果是普通指针的话，7 这个位置存的这个值是下面这个节点的地址。只不过把这个地址换成了哈希值。

## 状态树的版本管理

每次发布一个新的区块的时候，这个状态树中有一些节点的值会发生变化。这些改变不是在原地改的，而是新建一些分支，原来的状态其实是保留下来的。

这个例子当中，我们显示有两个区块，这是两个相邻的区块。这个 State Root 就是状态树的根哈希值，下面显示的是这棵树。这个是新的区块的状态树。

我们可以看到虽然每个区块有一个状态树，但是这两棵树的大部分节点是共享的。像右边这个树主要都是指向左边这棵树的节点，只有那些发生改变的节点是需要新建一个分支。

这个例子当中，是这个账户发生了变化。这个账户是一个合约账户，因为他有 code，有代码还有存储。合约账户的存储也是用 MPT 的形式保存下来的。

这个存储是什么？其实也是一个 Key-Value Store，就是维护的是从这个变量到这个变量取值的一个映射。它也是一个 Key-Value Store，在以太坊当中也是用了一颗 MPT。

所以**以太坊中的这个结构是一个大的 MPT 包含很多小的 MPT**，每一个合约账户的存储都是一颗小的 MPT。

回到我们这个例子，这个账户在新的区块中，这个交易次数 nonce 发生变化了，这个 balance 余额也发生了变化，这个代码是不变的。所以这个 code hash 是指向原来的这个节点，原来树中的节点。

存储是变了的，但是存储底下这个就叫存储树，存储树中大部分节点也是没有改变。这个例子当中，只有这底下的一个节点，这个整数变量从 29 变成了 45，所以新建的一个分支。

所以**系统中每个全节点需要维护的不是一颗 MPT，而是每次出现一个区块都要新建一个 MPT**。只不过这些状态树中大部分的节点是共享的，只有少数发生变化的节点是要新建分支。

### 为什么要保留历史状态？

我们问一个问题，为什么要保留历史状态？干嘛不在原地直接改了？

**原因一：审计 (Audit)**

假设有一个账户没有经过授权就擅自被人改掉了，然后你收到这样一个消息之后，你可以查一下历史记录，这个账户原来一笔一笔是怎么来的，就像银行一样，银行实际上是保留你的账户的历史信息的。你查过去什么交易都可以查得到。

**原因二：回滚 (Rollback)**

我们说系统当中有的时候会出现分叉。临时性的分叉其实是很普遍的。以太坊把出块时间降到十几秒之后，这种临时性的分叉是一种常态。因为你这个区块在网上传播时间可能也需要十几秒。

假设有一个分叉，两个节点同时获得记账权，这两个分叉最后会有一个胜出。比如说上面那个节点胜出了，下面这个分叉的节点该怎么办？

**回滚**。怎么回滚呢？就是把当前节点的状态——接受下面这个区块的状态要取消掉，退回到上一个区块的状态，然后再沿着上面这条链往下推进。

有的时候我们可能需要把当前状态退回到没有处理这个区块中交易的前一个状态。那怎么实现回滚呢？

就是要维护这些历史记录。

**与比特币的区别：**

这个跟比特币还不太一样。如果是比特币的话，它交易类型比较简单，有的时候你可以通过这种反向操作推算出前一个状态。

比如说如果就是简单的转账交易，A 转给 B 十个比特币，那这个对账户余额有什么影响？A 的账户上少了十个比特币，B 的账户多了十个比特币。假设这个交易要回滚了，退回到前一个状态，那就把 B 这个账户减少十个比特币，把 A 这个账户加回去十个比特币就行了。

这个是简单的转账交易，你要回滚其实是比较容易的。

**以太坊中为什么不行？**

以太坊中有智能合约。以太坊的智能合约是图灵完备的，它编程功能是很强的，从理论上说可以实现很复杂的功能，它跟比特币的那个简单的脚本还不一样。

所以以太坊中如果你不保存以前的状态，智能合约执行完之后，你想再推算出前面是什么状态，这是不可能的。合约里代码是怎么写的，你没有办法自动推算出前面的状态。

所以要想支持回滚，必须得保存历史状态。

## 以太坊中的数据结构

下面我们看一下以太坊中代码的一些数据结构，这个是 Block Header 块头的定义：

1. **ParentHash**：父区块的哈希值，就是区块链中前一个区块的块头的哈希值
2. **UncleHash**：叔叔区块的哈希值，这是比较新鲜的。它是叔叔区块的哈希值。我们后面讲共识协议的时候，每个区块还可以有叔叔区块
3. **Coinbase**：挖出这个矿的这个区块的矿工的地址

下面这三个就是跟我们这几个章节讲的很相关的了：

**三棵树的根哈希**：

- **StateRoot**：我们今天讲的状态树的根哈希值
- **TransactionHash**：交易树的根哈希值，这个有点类似于比特币系统中的那个根哈希值
- **ReceiptHash**：收据树的根哈希值，这是一个新的

4. **BloomFilter**：这个跟那个收据树是相关的，提供了一种高效的查询符合某种条件的交易的执行结果
5. **Difficulty**：挖矿的难度，这个也是要根据需要调整的
6. **GasLimit** 和 **GasUsed**：这个是跟汽油费相关的。智能合约要消耗汽油费，就有点类似于比特币中的交易费
7. **Timestamp**：这个区块的大致的产生时间
8. **MixDigest** 和 **Nonce**：这两个是跟挖矿过程相关的。这个 Nonce 也是一个挖矿时猜的那个随机数，就是类似于比特币的挖矿，以太坊中挖矿也是要猜很多随机数。写在这个块头里的这个随机数是最后找到的符合难度要求的。这个 MixDigest 是从这个 Nonce 这个随机数经过一些计算，算出了一个哈希值

**区块的结构：**

对我们来说，比较相关的就是前面三个域：

- **Header**：指向 Block Header 的指针
- **Uncle**：指向叔叔区块的头的指针，而且它是个数组，因为一个区块可以有多个叔叔区块
- **Transaction**：这个区块中的交易的列表

**StorageBlock**：这个区块真正在网上发布的时候发布的就是这些信息，其实就是我们刚才看到的前三项。

## RLP 编码

我们讲了半天状态树中保存的是 Key-Value Pair。

Key 就是地址，我们讲到现在主要讲的是这个键值，这个地址的管理方式。那么这个 Value，这个账户的状态，它是怎么存储在状态树当中的？

实际上它是要经过一个序列化的过程，**RLP 编码**，用这个编码做序列化之后再存储。

**RLP 是什么意思？**

**Recursive Length Prefix**，是一种做序列化的方法。特点是简单，是极简主义，越简单越好。

大家听说过 Protocol Buffers 吗？这是个很有名的做序列化的库，很常用的做序列化库。

跟这些库相比，RLP 的理念就是越简单越好，它只支持一种类型：

**Nested Array of Bytes**

说白了就是字节数组，有一个一个字节组成的数组，可以嵌套。

以太坊中所有的其他类型——整数也好，比较复杂的数据结构也好，最后都要变成这个 Nested Array of Bytes。

所以你要实现一个 RLP 比实现 Protocol Buffers 要容易很多，因为复杂的东西它都不做，都推给应用层做。

---

**总结：**

今天这个章节内容是比较多的，我们从以太坊中设计的理念开始讲，为什么要这样设计？一步一步讲到这儿。

下个章节会讲一下以太坊中另外两棵树：交易树和收据树。
