**17. ETH 交易树和收据树**

我们上个章节讲了以太坊中的状态树，以太坊中还有另外两棵树：交易树和收据树。

## 交易树和收据树概述

每次发布一个区块的时候，这个区块里所包含的那些交易会组织成一棵交易树，也是一颗 Merkle Tree，跟比特币中的情况是类似的。同时以太坊还增加了一个收据树，每个交易执行完之后会形成一个收据，记录这个交易的相关信息。交易树跟收据树上面的节点是一一对应的。

增加这个收据树主要是考虑到以太坊的智能合约执行过程比较复杂，所以通过增加这个收据树的结构，有利于我们快速查询一些执行的结果。

从数据结构上，交易树和收据树都是 MPT，就是我们上个章节讲的 Merkle Patricia Tree。

### 与比特币的区别

这个数据结构跟比特币有所区别。比特币中的交易树就是用普通的 Merkle Tree，就是区块里的所有交易组织成一个普通的 Merkle Tree。

当然 MPT 也是一种 Merkle Tree，这个叫 Merkle Patricia Tree，它也是一种 Merkle Tree。但是跟比特币中用的不是完全一样。

**为什么有这个区别呢？**

我猜其实就是为了方便以太坊中的三棵树都用同样的数据结构，这样代码比较统一，便于管理，不一定非要有什么更深层次的原因。

当然了，用 MPT 的一个好处是它支持查找操作，就是你可以通过键值从顶向下沿着这个树进行查找：

- 对于状态树来说，查找的键值就是这个账户的地址
- 对于交易树和收据树来说，查找的键值就是这个交易在发布的区块里面的序号，就是它排第几

这个交易的排列顺序是由发布区块的那个节点决定的。

### 三棵树的重要区别

这三棵树有一个比较重要的区别：

- **交易树和收据树**：都是只把当前发布的这个区块的交易组织起来的
- **状态树**：是把系统中所有账户的状态都要包含进去，不管这些账户跟当前区块的交易有没有什么关系

从这个数据结构上来说，我们上个章节讲过，多个区块的状态树是共享节点的。每次新发布一个区块的时候，只有这个区块中的交易影响了、改变了状态的那些节点需要新建一个分支，其他的节点都是沿用原来存在树上的节点就行了。

相比之下，交易树和收据树，每个区块的交易树和收据树都是独立的，它们是不会共享节点的，因为一个区块跟另外一个区块发布的交易本身我们也认为是独立的。

## 交易树和收据树的用途

### 基本用途：提供 Merkle Proof

交易树和收据树有什么用呢？一个用途就是提供 Merkle Proof，就像比特币当中交易树可以用来证明某个交易被打包到某个区块里面了，就可以向轻节点提供这样的 Merkle Proof。收据树也是类似的，你要证明某个交易的执行结果，也可以在收据树里面提供一个 Merkle Proof。

### 高级用途：复杂查询操作

除此之外，以太坊还支持一些更加复杂的查询操作。比如说你想找到过去十天当中所有跟某个智能合约有关的交易，那这个应该怎么查呢？

**传统方法的问题：**

一种方法是把过去十天产生的所有区块都扫描一遍，看看其中有哪些交易是跟这个智能合约相关的。但这种方法的复杂度就比较高，而且对于轻节点来说，实际上轻节点没有交易列表，它只有一个块头的信息。所以它也没有办法通过扫描所有交易列表的方法来找到符合这种查询条件的交易。

**类似的查询需求：**

比如说找到过去十天当中符合某种类型的所有事件：
- 所有的众筹事件
- 所有的发行新币的事件

这些都是需要一个比较高效的方法才能支持。

**解决方案：** 以太坊中引入了 **Bloom Filter** 这个数据结构。

## Bloom Filter 原理

大家以前学过 Bloom Filter 吗？

### 基本概念

Bloom Filter 这个数据结构可以支持比较高效的查找某个元素是不是在一个比较大的集合里面。比如说你有一个集合里面有很多元素，那么现在你想知道某个指定的元素是不是在这个集合里，怎么办？

**传统方法：**

一个最笨的方法是把这个集合中的元素遍历一遍，看看有没有我想找的那个元素。这个的复杂度是线性的，是 O(n) 的复杂度。

另外还有一个前提是：你得有足够的存储来保存整个集合的元素。对于轻节点来说，它其实没有这个交易列表，它没有整个集合的元素信息，所以这种方法它是用不了的。

### Bloom Filter 工作原理

Bloom Filter 用一个很巧妙的思想：给这个大的集合（包含很多元素的集合）计算出一个很紧凑的摘要，比如说一个 128 位的向量。

**例子说明：**

假设有一个集合 {A, B, C}，我们要给它计算出一个 digest。

底下是一个位向量，这个向量初始的时候都是 0，然后我们有一个哈希函数 H，它把每一个元素映射到向量中的某个位置：

1. A 这个元素取哈希之后映射到某个位置，然后我就把这个位置的元素从 0 变成 1
2. B 可能映射到另一个位置，那么这个地方也置成 1
3. C 映射到第三个位置，也变成 1

就是把每一个元素都取哈希，找到向量中的对应位置，然后把它置成 1。所有的元素都处理完了，得到这个向量，就是原来集合的一个摘要。

**这个摘要比原来的集合要小很多**，在我们这个例子当中，比如说你就用一个 128 位就可以代表了。

### 查询操作

这个摘要有什么用呢？

比如说我们有一个元素叫 D，我们想知道 D 这个元素是不是在这个集合里。但是这个集合本身我们不一定能够保存下来，应该怎么办？

我们用这个哈希函数对 D 取哈希值，比如说取完之后发现映射到某个地方：

1. **映射到一个为 0 的位置**：说明这个元素一定不在这个集合里
2. **映射到一个为 1 的位置**：说明什么？不能确定！

为什么不能确定？

如果 D 映射到一个为 1 的地方，有可能是它确实是集合中的元素（比如说 D 就等于 A，所以我们把它找到了），也有可能它不在这个集合里面，但是出现了哈希碰撞，恰好映射到了一个跟集合中某个元素一样的位置。

### Bloom Filter 的特性

所以用这个 Bloom Filter，我们要注意它有可能出现 **False Positive**，但是不会出现 **False Negative**：

- **可能出现误报**：不在集合里的元素可能被判断为在集合里
- **不会出现漏报**：在集合里的元素一定会被判断为在集合里

这是 Bloom Filter 的一个基本的工作原理。

### Bloom Filter 的变种

Bloom Filter 有各种各样的变种，比如说为了解决这个哈希碰撞问题，有的 Bloom Filter 的设计用的不是一个哈希函数，而是一组哈希函数。那么每个哈希函数独立地把这个元素映射到这个向量中的某一个位置。

用一组哈希函数的好处是：如果出现哈希碰撞，那么一般来说不会所有的哈希函数都同时出现碰撞。

### Bloom Filter 的局限性

从这个集合中删除一个元素该怎么操作？

**答案是：没法操作。**

Bloom Filter 这个数据结构的一个局限性是不支持删除操作。原因是：比如说你把 A 这个元素删掉了，对应位置是 1，你要不要改成 0？如果你把它改成 0 的话，这个集合中有可能有另外一个元素也映射到这个位置，就是哈希碰撞是有可能的。

如果你要支持删除操作的话，这个地方就不能用 binary bit，不能是 0 和 1 了。你得把它改成一个计数器，记录这个位置有多少个元素映射过来。而且你还要考虑到这个计数器会不会 overflow。这样数据结构就复杂多了，跟当初设计 Bloom Filter 的初衷是相违背的。

所以一般来说，Bloom Filter 是不支持删除操作。

## 以太坊中的 Bloom Filter 应用

那以太坊中要这个 Bloom Filter 有什么用呢？

### 结构设计

我们说每个交易执行完之后会形成一个收据。这个收据里面就包含了一个 Bloom Filter，记录这个交易的类型、地址等其他信息。

发布的区块在它的块头里也有一个总的 Bloom Filter，这个总的 Bloom Filter 是这个区块里所有交易的 Bloom Filter 的一个并集。

### 查询流程

回到我们刚才那个例子，比如说你要查找过去十天发生的跟某个智能合约相关的所有交易，你怎么找呢？

1. **第一步：快速过滤**
   - 先查一下哪个区块的块头里的 Bloom Filter 有我要的这个交易的类型
   - 如果块头的 Bloom Filter 里没有的话，那么我们就知道这个区块不是我们想要的

2. **第二步：精确查找**
   - 如果块头的 Bloom Filter 有的话，我们再去查找这个区块里面包含的交易所对应的收据树里面的那些 Bloom Filter
   - 看每个收据的 Bloom Filter 哪个有，也可能都没有（因为它有可能是 False Positive）
   - 如果是有的话，我们再找到相对应的交易，直接进行一下确认

### 优势

这个好处是什么？好处是通过这个 Bloom Filter 的结构，能够**快速过滤掉大量无关的区块**。很多区块你一看块头的 Bloom Filter 就知道，肯定不会有我们要的交易。

然后剩下的一些少数的候选区块，我们再仔细查看。比如说你是个轻节点，轻节点的话你只有块头信息。那么根据块头就已经能够过滤掉很多区块，剩下有可能是你想要的那些区块，你再去问全节点要一些进一步的信息。

## 以太坊作为状态机

基本上，我们就把以太坊中的三棵树给讲完了。这三个树的根哈希都是包括在块头里面的。

### 以太坊的状态机模型

以太坊的运行过程可以把它看作是一个**交易驱动的状态机**：

- **状态**：就是所有账户的状态，就是状态树中包含的那些内容
- **交易**：就是每次发布的区块里包含的那些交易

这些交易通过执行会驱动系统从当前的状态转移到下一个状态。

### 与比特币的对比

比特币呢？比特币你也可以认为是一个交易驱动的状态机：

- **比特币中的状态**：UTXO，没有被花掉的那些输出
- **状态转移**：每次新发布一个区块会从 UTXO 里用掉一些输出，又会增加一些新的输出

所以发布这个区块会驱动这个状态机从当前的状态转移到下一个状态。所以 UTXO 可以认为是比特币状态机中的状态。

### 确定性特征

这两个状态机有一个共同的特点，就是**状态转移都得是确定性的**：

对于一个给定的当前状态，一个给定的一组交易（就是这个区块中包含的这些交易），能够确定性地转移到下一个状态。

因为所有的全节点、所有的矿工都要执行同样的状态转移，所以状态转移必须是确定性的。

## 一些思考问题

### 问题一：新账户的处理

比如说有人在以太坊上发布一个交易，某个节点收到这个交易。这个交易说转账从 A 转到 B，有没有可能这个收款人的地址，这个节点以前从来没听说过？

**答案：** 可能。以太坊跟比特币是一样的，创建账户的时候是不需要通知其他人的。只有这个账户第一次收到钱的时候，其他的节点才会知道这个账户的存在。这个时候要在这个状态树中新插入一个节点，因为这是一个新增加的账户。

### 问题二：状态树设计的思考

我们前面讲状态树和交易树、收据树的一个区别是，状态树要包含系统中所有账户的状态，无论这些账户是否参与了当前区块中的交易。

那么能不能把这个状态树的设计改一下，改成每个区块的状态树也只包含这个区块中的交易相关的那些账户的状态？

这样就跟交易树和收据树一致了，而且可以大幅度削减每个区块所对应的状态树的大小，因为大部分的账户状态是不会变的。

**这样可以吗？**

### 问题分析

如果这么设计的话，实际上相当于什么？相当于比特币的基于交易的账户模型。

这么设计的一个问题是：**你要想查找某个账户的状态就不方便了。**

比如说你有个转账交易，A 转给 B 10 个以太币。我们前面讲过要检查什么？A 这个账户里是不是真的有 10 个以太币。

问题是 A 这个账户在当前区块或最近一个区块对应的状态树可能没有 A 这个账户。所以你要往前找，一直找到最近的一个包含这个 A 账户的区块，然后才能知道 A 的账户余额是多少。

**不方便的地方：** 如果 A 这个账户有比较长的一段时间没有发生任何交易，你可能要从后往前扫描很多个区块，才能找到他最近一次的账户状态。

**更大的问题：** 

我们说 A 转给 B 这个钱的时候，你要知道 A 账户的状态，才能知道 A 是不是有足够的钱转给 B 10 个以太币。你也要知道 B 的账户状态是什么，他当前的余额是多少，因为你要往上面加 10 个以太币。

所以你也要找 B 这个账户的状态，而 B 这个账户有可能是个新建的账户，这个时候你要找到哪儿去？你要从当前的区块一直扫描到创世纪块，发现 B 这个账户没有，才知道原来是个新建的账户。

这就是这么设计的问题所在。

## 代码实现细节

下面我们看一下代码中的一些具体的数据结构。

### 交易树和收据树的创建过程

在 `newBlockG` 这个函数里面创建了交易树和收据树，并且得到它们的根哈希值。

**交易树的代码：**
```go
// 首先判断一下交易列表是否为空
if len(transactions) == 0 {
    // 如果是空的话，那么这个区块的块头里的交易树的根哈希值就是一个空的哈希值
    header.TxHash = emptyRootHash
} else {
    // 否则的话通过调用 DeriveSha 这个函数来得到交易树的根哈希值
    header.TxHash = DeriveSha(transactions)
}
```

**收据树的代码：**
```go
// 首先判断一下收据列表是否为空
if len(receipts) == 0 {
    // 如果是空的话，那么块头里收据树的根哈希值就是一个空的哈希值
    header.ReceiptHash = emptyRootHash
} else {
    // 如果不为空的话，那么也是通过调用 DeriveSha 这个函数来得到收据树的根哈希值
    header.ReceiptHash = DeriveSha(receipts)
    // 然后创建块头里的 Bloom Filter
    header.Bloom = CreateBloom(receipts)
}
```

我们前面讲过，每个交易执行完后会得到一个收据，所以交易列表的长度跟收据列表的长度应该是一样的。

### DeriveSha 函数

前面 `newBlockG` 函数创建交易树和收据树的时候，调用的都是这个 `DeriveSha` 函数。它这里创建的数据结构是一颗 Trie。

而 Trie 的数据结构是一颗 MPT（Merkle Patricia Tree），以太坊中的三棵树——状态树、交易树、收据树，用的都是 MPT。

### Receipt 数据结构

```go
type Receipt struct {
    // ... 其他字段
    Bloom Bloom       // 这个收据的 Bloom Filter
    Logs  []*Log      // Log 数组，每个收据可以包含多个 log
}
```

每个交易执行完之后形成一个收据，记录了这个交易的执行结果。这里的 `Bloom` 域就是这个收据的 Bloom Filter。这个 `Logs` 是个数组，每个收据可以包含多个 log，这个收据的 Bloom Filter 就是根据这些 log 产生出来的。

### 块头中的 Bloom Filter

这是我们上个章节看过的区块的块头的数据结构，里面那个 `Bloom` 域就是整个区块的 Bloom Filter。它是由我们刚才看到的每个收据的 Bloom Filter 合并在一起得到的。

### Bloom Filter 相关函数

这是相关的三个函数的代码实现：`CreateBloom`、`LogsBloom` 和 `Bloom9` 这 3 个函数的代码实现。

**CreateBloom 函数：**
```go
func CreateBloom(receipts Receipts) Bloom {
    // 参数是这个区块的所有收据
    // 通过循环对每个收据调用 LogsBloom 函数来生成这个收据的 Bloom Filter
    // 然后把这些 Bloom Filter 合并起来，用 OR 操作合并起来
    // 得到整个区块的 Bloom Filter
}
```

**LogsBloom 函数：**
```go
func LogsBloom(logs []*Log) *big.Int {
    // 功能是生成每个收据的 Bloom Filter
    // 参数是这个收据的 logs 数组
    // 有两层循环：
    // - 外层循环对 log 数组里的每一个 log 进行处理
    // - 首先把这个 log 的地址加入到 Bloom Filter 里面
    // - 内层循环，把这个 logs 中包含的每个 topic 加入到 Bloom Filter 里
    // 这样就得到了这个收据的 Bloom Filter
}
```

### Bloom9 哈希函数

`Bloom9` 是 Bloom Filter 中使用的哈希函数，它跟我们之前讲的有一点区别。我们那个例子中的哈希函数是把集合中的每个元素映射到 digest 中的某一个位置。

这里的 `Bloom9` 函数是把输入映射到位数组中的**三个位置**，也就是说把三个位置都置为 1。

**Bloom9 函数的代码：**
```go
func Bloom9(data []byte) *big.Int {
    // 第一行调用 crypto 里面的函数生成一个 256 位的哈希值
    // 这里的 b 是个 32 个字节的哈希值
    b := crypto.Keccak256(data)
    
    // r 是我们最后要返回的 Bloom Filter，初始化为 0
    r := new(big.Int)
    
    // 循环，把刚才生成的 32 字节的哈希值取前 6 个字节
    // 每两个字节组成一组拼接在一起
    // 然后按位与上 2047，相当于对 2048 取余
    // 得到了一个位于 0 到 2047 这个区间里的数
    // 之所以要这样做，是因为以太坊中 Bloom Filter 的长度是 2048 位
    for i := 0; i < 6; i += 2 {
        t := big.NewInt(1)
        b := (uint(b[i+1]) + (uint(b[i]) << 8)) & 2047
        r.Or(r, t.Lsh(t, b))
    }
    
    // 经过三轮循环，把三个位置置为 1 后，返回所创建的 Bloom Filter
    return r
}
```

### Bloom Filter 查询

前面讲的是生成 Bloom Filter 的过程，那么怎么查询某个 Bloom Filter 里面是否包含了我们感兴趣的 topic 呢？

这是通过调用 `BloomLookup` 函数来实现的：

```go
func BloomLookup(bloom Bloom, topic []byte) bool {
    // 需要查一下这个 Bloom Filter 里有没有包含我们要找的 topic
    // 首先用刚才讲的 Bloom9 函数把这个 topic 转换成一个 bit vector
    // 然后把它跟这个 Bloom Filter 做按位与操作
    // 看看得到的结果是不是跟这个 bit vector 相等
    
    // 注意：这个 Bloom Filter 里面可能还包含有其他的 topic
    // 除了我们要查找的这个 topic 之外，还可以包含其他的 topic
    // 所以要先做一个 AND，然后再跟它自身比较
    // 相当于判断一下我们要查找的这个 topic 在 Bloom Filter 中对应的位置是不是都是 1
}
```

---

**总结：**

这就是我们这个章节要讲的内容。我们详细介绍了以太坊中交易树和收据树的设计原理、Bloom Filter 的工作机制，以及它们在实际代码中的实现细节。通过这些内容，我们可以更好地理解以太坊作为一个交易驱动的状态机是如何高效地处理和查询交易数据的。
